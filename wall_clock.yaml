substitutions:
  device_name: wall_clock
  upper_device_name: Wall Clock
  
esp8266:
  board: d1_mini
  restore_from_flash: yes
  # framework:
  #   version: 2.7.4

esphome:
  name: $device_name
  on_boot:
    then:
      - light.turn_on:
          id: $device_name
          effect: "Clock"

wifi: !include include/wifi_iot.yaml

captive_portal:

web_server:
  port: 80

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
# api:

ota:

mqtt: 
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: false
  birth_message:
    topic: $device_name/availability
    payload: online
  will_message:
    topic: $device_name/availability
    payload: offline
  on_message:
    topic: $device_name/markers/command
    then:
      - lambda: |-
          if(x=="0") id(marker_setting) = 0;
          if(x=="1") id(marker_setting) = 1;
          if(x=="2") id(marker_setting) = 2;

globals:
   - id: marker_setting
     type: int
     restore_value: yes
     initial_value: '2'
     ## 0 - none
     ## 1 - main
     ## 2 - all
      
button:
  - platform: restart
    name: $upper_device_name Restart

  - platform: template
    name: $upper_device_name Random Effect
    id: random_effect
    on_press:
      - light.turn_on:
          id: $device_name
          effect: !lambda |-
    
            std::string effects[] = {
                "Clock",
                "Clock Backfill",
                "Clock Backwards",
                "Clock Basic",
                "Clock Candy Cane",
                "Clock Comet",
                "Clock Flicker",
                "Clock Fly",
                "Clock Marquee",
                "Clock Glitter",
                "Clock Inverse",
                "Clock Tourbillon",
                "Police 3",
                "Rainbow Spinner",
                "Color Test",
                "Color Wipe"
              };
            int num_effects = 16;
    
            int i = rand() % num_effects;
    
            return effects[i];
            
binary_sensor:
  - platform: gpio
    pin: D8
    id: d8_button
    filters:
      - delayed_on_off: 10ms
    
    on_click:
      - min_length: 50ms
        max_length: 350ms
        then:
          button.press:
            id: random_effect
    
      - min_length: 1s
        max_length: 5s
        then:
        - light.toggle: $device_name
    
sensor:
  - platform: wifi_signal
    name: $upper_device_name WiFi Signal
    update_interval: 30min
    icon: mdi:wifi

text_sensor:    
  - platform: template
    name: $upper_device_name Marker Setting
    id: marker
    state_topic: $device_name/markers/state
    lambda: |-
      static int previous_value = -1;
      if(id(marker_setting) != previous_value){
        previous_value = id(marker_setting);
        if (id(marker_setting) == 0) return {"None"};
        if (id(marker_setting) == 1) return {"Main"};
        if (id(marker_setting) == 2) return {"All"};
      }
      return {};
    update_interval: 1s

time:
  - platform: sntp
    id: esptime
    timezone: America/Detroit
    servers:
      - 192.168.254.118
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    
light:
  # - platform: fastled_clockless
  #   chipset: WS2811
  #   pin: GPIO5
  #   num_leds: 60
  #   rgb_order: GRB
  #   id: led_circle
  #   internal: true
  
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO5
    num_leds: 60
    id: led_circle
    internal: true
    
## Using a partition light to set the "12" setting of the clock at something 
## other than 0 on the circle. Adjust the from: and to: settings as needed.
  - platform: partition
    id: $device_name
    name: $upper_device_name
    segments:
      - id: led_circle
        from: 30
        to: 59
      - id: led_circle
        from: 0
        to: 29
    on_turn_on:
      then:
        - light.turn_on:
            id: $device_name
            effect: "Clock"
    effects:
      - addressable_lambda:
          name: Clock
          update_interval: 33ms
          lambda:
            static int wipe = 0;
            static int noon_wipe = 0;
            static int step;
            static int blink = 0;
            static int hour_loc = 0;
            static int min_loc = 0;
            static boolean first_wipe = false;
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color wipe_color = Color(255,165,0);
            const Color paun_wipe_color = Color(179,124,0);
            const Color half_wipe_color = Color(128,83,0);
            const Color quart_wipe_color = Color(64,41,0);
            const Color eighth_wipe_color = Color(32,20,0);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            
            if(initial_run){
              first_wipe = true;
            }
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            if(first_wipe){
              if(wipe < it.size() - 1){
                for(int i = 0;i < wipe + 1;i++){
                  it[i] = Color(0,0,0);
                  if(id(marker_setting) > 1){
                    if(i % (it.size() / 12) == 0){
                      it[i] = minor_indicator_color;
                    }
                  }
                  if(id(marker_setting) > 0){
                    if(i % (it.size() / 4) == 0){
                      it[i] = indicator_color;
                    }
                  }
                  if(i == second){
                    it[i] = second_color;
                  }
                  if(i == minute){
                    it[i] = minute_color;
                  }
                  if(i == hour){
                    it[i] = hour_color;
                  }
                }
                wipe += 1;
              } else {
                wipe = 0;
                first_wipe = false;
              }
            } 
            
            if(first_wipe == false){
            
              for(int i = 0; i < it.size();i++){
                if(id(marker_setting) > 1){
                  if(i % (it.size() / 12) == 0){
                    it[i] = minor_indicator_color;
                  }
                }
                if(id(marker_setting) > 0){
                  if(i % (it.size() / 4) == 0){
                    it[i] = indicator_color;
                  }
                }
              }
              
              if(second < 60){
                it[second] = second_color;
              }
              
              if(second == 1 && !(hour == 0 && minute == 0)){
                if(minute < 30){
                  step = -2;
                  if(min_loc < 1) min_loc = 59;
                } else{
                  step = 2;
                }
                if((step < 0 && min_loc > minute) || (step > 0 && min_loc < minute)){
                  it[min_loc] = minute_color;
                  min_loc = min_loc + step;
                } else {
                  it[minute] = minute_color;
                }
              } else {
                it[minute] = minute_color;
                min_loc = 0;
              }
              
              if(second == 0 && !(hour == 0 && minute == 0)){
                if(hour < 30){
                  step = -2;
                  if(hour_loc < 1) hour_loc = 59;
                } else{
                  step = 2;
                }
                if((step < 0 && hour_loc > hour) || (step > 0 && hour_loc < hour)){
                  it[hour_loc] = hour_color;
                  hour_loc = hour_loc + step;
                } else {
                  it[hour] = hour_color;
                }
              } else {
                it[hour] = hour_color;
                hour_loc = 0;
              }
              
              if(hour == 0 && minute == 0 and second < 2){
                step = 1;
                if(noon_wipe < it.size()){
                  it[noon_wipe] = hour_color;
                  if(noon_wipe > 0){
                    it[it.size() - noon_wipe] = minute_color;
                  }
                }
                noon_wipe += step;
              } else {
                noon_wipe = 0;
              }
              
              if(hour == minute && second > 1){
                if(second % 2 == 1){
                  it[minute] = minute_color;
                  ESP_LOGD("same", "Hour equal minute");
                }
              }

              if(hour == second || minute == second ){
                ESP_LOGD("same", "Second hides behind hour or minute");
                if(blink == 0){
                  it[second] = Color(255,255,255);
                  blink += 1;
                } else {
                  blink += 1;
                  blink = blink % 5;
                }
              }
              
              if(minute == 59 && second == 59 && wipe < it.size() - 1){
                
                it[wipe] = wipe_color;
                if(wipe > 0){
                  it[wipe-1] = paun_wipe_color;
                  if(wipe > 1 ){
                    it[wipe-2] = half_wipe_color;
                    if(wipe > 2 ){
                      it[wipe-3] = quart_wipe_color;
                      if(wipe > 3){
                        it[wipe-4] = eighth_wipe_color;
                      }
                    }
                  }
                }
                
                wipe += 2;
              } else {
                wipe = 0;
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }

            
      - addressable_lambda:
          name: Clock Backfill
          update_interval: 33ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);

            Color colors[3];
            int points[3] = {0,0,0};

            static int hour_wipe = 0;
            static int minute_wipe = 0;
            static int end_match_wipe = 0;
            static int beg_match_wipe = 0;
            int state = 0;
            int step = 0;

            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }

            int minute = time.minute;
            int hour = time.hour;
            hour = (hour % 12) * 5;
            int second = time.second;

            int hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;

            if(hour <= minute && second >= minute){
                points[0] = hour;
                colors[0] = hour_color;
                points[1] = minute;
                colors[1] = minute_color;
                points[2] = second;
                colors[2] = second_color;
                if(second == hour || second == minute ) ESP_LOGD("Backfill","First!");
            } else if(hour <= second && minute >= second){
                points[0] = hour;
                colors[0] = hour_color;
                points[1] = second;
                colors[1] = second_color;
                points[2] = minute;
                colors[2] = minute_color;
                if(second == hour || second == minute  ) ESP_LOGD("Backfill","Second");
            } else if(minute < hour && second >= hour ){
                points[0] = minute;
                colors[0] = minute_color;
                points[1] = hour;
                colors[1] = hour_color;
                points[2] = second;
                colors[2] = second_color;
                if(second == hour || second == minute  ) ESP_LOGD("Backfill","Third");
            } else if(minute <= second && hour >= second ){
                points[0] = minute;
                colors[0] = minute_color;
                points[1] = second;
                colors[1] = second_color;
                points[2] = hour;
                colors[2] = hour_color;
                if(second == hour || second == minute  ) ESP_LOGD("Backfill","Fourth");
            } else if(second <= hour && minute >= hour ){
                points[0] = second;
                colors[0] = second_color;
                points[1] = hour;
                colors[1] = hour_color;
                points[2] = minute;
                colors[2] = minute_color;
                if(second == hour || second == minute  ) ESP_LOGD("Backfill","Fif");
            } else if(second <= minute && hour >= minute ){
                points[0] = second;
                colors[0] = second_color;
                points[1] = minute;
                colors[1] = minute_color;
                points[2] = hour;
                colors[2] = hour_color;
                if(second == hour || second == minute  ) ESP_LOGD("Backfill","Sixth");
            } else {
              ESP_LOGD("Backfill","Fallthru!!!! - Hour %d, Minute %d, Second %d", hour, minute, second);
            }
            
            it.all() = Color(0,0,0);

            state = 0;

            for(int i = 0; i< 60; i++){

              if(hour == minute && points[state] == hour ){
                if (hour % 2 == i % 2){
                  it[i] = hour_color;
                } else {
                  it[i] = minute_color;
                }
              } else {
                it[i] = colors[state];
              }

              if(hour == minute && second == 0 && hour != 0 ){
                if( points[state] == minute ){
                  int range = hour;
                  if(range < 0) range = range + 60;
                  if(range > 23 || range == 0){
                    step = 2;
                  } else {
                    step = 1;
                  }
                  if( i > beg_match_wipe && beg_match_wipe <= hour){
                    it[i] = minute_color;
                  }
                }
              } else {
                beg_match_wipe = 0;
              }

              if(hour == minute && second == 59 && hour != 59 ){
                if( points[state] == hour ){
                  int range = hour;
                  if(range < 0) range = range + 60;
                  if(range > 23 || range == 0){
                    step = 2;
                  } else {
                    step = 1;
                  }
                  if( i < end_match_wipe && end_match_wipe <= hour){
                    it[i] = hour_color;
                  }
                }
              } else {
                end_match_wipe = 0;
              }
              
              if(second == hour && second != minute){
                if( points[state] == hour ){
                  int range = hour - minute;
                  if(range < 0) range = range + 60;
                  if(range > 23 || range == 0){
                    step = 2;
                  } else {
                    step = 1;
                  }
                  if( 
                      ( minute >= hour && i < hour_wipe && hour_wipe <= hour )
                   || ( minute >= hour && i > hour_wipe && hour_wipe <= hour && i > points[2] )
                   || ( minute >= hour && i < hour_wipe && hour_wipe > hour && i > points[2]  )  
                   || ( minute < hour && i < hour_wipe && i > minute && hour_wipe < hour ) 
                   || ( minute < hour && i > hour_wipe && i > hour && hour_wipe > hour )
                    ) {
                    it[i] = second_color;
                  }
                }
              } else {
                hour_wipe = hour;
              }
              
              if(second == minute && second != hour){
                if( points[state] == minute ){
                  int range = minute - hour;
                  if(range < 0) range = range + 60;
                  if(range > 23){
                    step = 2;
                  } else {
                    step = 1;
                  }
                  if(
                      ( hour >= minute &&  i < minute_wipe && minute_wipe <= minute )
                   || ( hour >= minute && i > minute_wipe && minute_wipe <= minute && i > points[2] )
                   || ( hour >= minute && i < minute_wipe && minute_wipe > minute && i > points[2]  )  
                   || ( hour < minute && i < minute_wipe && i > hour && minute_wipe < minute  )
                   || ( hour < minute && i > minute_wipe && i > minute && minute_wipe > minute )
                    ) {
                    it[i] = second_color;
                  }
                }
              } else {
                minute_wipe = minute;
              }

              for(int j = 0; j < 3; j++){
                if( i == points[state] ){
                  state = ++state % 3;
                }
              }
            }
                
            if(second == hour){
              hour_wipe = (hour_wipe - step);
              if(hour_wipe < 0) hour_wipe += 60;
            }
                
            if(second == minute && second != hour){
              minute_wipe = (minute_wipe - step);
              if(minute_wipe < 0) minute_wipe += 60;
            }

            if(hour == minute && second == 0){
              beg_match_wipe = beg_match_wipe + step;
              if(beg_match_wipe > 59) beg_match_wipe = 0;
            }

            if(hour == minute && second == 59 && end_match_wipe < hour){
              end_match_wipe = end_match_wipe + step;
              if(end_match_wipe > 59) end_match_wipe = 0;
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
            
      - addressable_lambda:
          name: Clock Backwards
          update_interval: 100ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            static int state = 0;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }
            
            if( second < 60){
              it[(60 - second) % 60] = second_color;
            }
            it[(60 - minute) % 60] = minute_color;
            it[(60 - hour) % 60] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[(60 - minute) % 60] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
            
      - addressable_lambda:
          name: Clock Basic
          update_interval: 100ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,145,255);
            const Color second_color = Color(0,200,200);
            int hour;
            int hour_adj;
            int minute;
            int second;
            static int state = 0;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
            
      - addressable_lambda:
          name: Clock Candy Cane
          update_interval: 100ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            static int cane_pos = 0;
            const int cane_width = 15;
            int cane_state = 0;
            
            if(initial_run){
              cane_pos = 0;
            }
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);

            for(int i = 0;i < 60; i++){
              int d = (i + cane_pos) % 60;
              if( i % 15 < cane_width/2){
                it[d] = Color(128,0,0);
              } else {
                it[d] = Color(128,128,128);
              }
            }
            
            cane_pos += 1;
            cane_pos = cane_pos % 60;
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }

            
      - addressable_lambda:
          name: Clock Comet
          update_interval: 250ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }


            for(int j = 0; j < 8; j++){
              int i = hour - j;
              if(i < 0) i = 60 + i;
              if( i > 59) i = i - 60;
              it[i] = Color(hour_color.r * ((10-j) * .10), hour_color.g * ((10-j) * .10), hour_color.b * ((10-j) * .10));
            }

            for(int j = 0; j < 8; j++){
              Color j_color = Color(minute_color.r * ((10-j) * .10), minute_color.g * ((10-j) * .10), minute_color.b * ((10-j) * .10));
              int i = minute - j;
              if(i < 0) i = 60 + i;
              if( i > 59) i = i - 60;
              if(hour == 1) continue;
              if((hour > i && hour - i < 8) || ( hour < i &&  i > hour + 52) ) {
                if( (j % 2) == 0 ){
                  it[i] = j_color;
                } else {
                  continue;
                }
              } else {
                it[i] = j_color;
              }
            }

            for(int j = 0; j < 8; j++){
              Color j_color = Color(second_color.r * ((10-j) * .10), second_color.g * ((10-j) * .10), second_color.b * ((10-j) * .10));
              int i = second - j;
              if(i < 0) i = 60 + i;
              if( i > 59) i = i - 60;
              if((hour > i && hour - i < 8) || ( hour < i &&  i > hour + 52) || hour == i) {
                if( (j % 2) == 0 ){
                  it[i] = j_color;
                } else {
                  continue;
                }
              } else if( (minute > i && minute - i < 8) || ( minute < i &&  i > minute + 52) || minute == i) {
                if( (j % 2) == 0 ){
                  it[i] = j_color;
                } else {
                  continue;
                }
              } else {
                it[i] = j_color;
                if(i == hour) ESP_LOGD("clock","Overwriting Hour");
                if(i == minute) ESP_LOGD("clock","Overwriting Minute");
              }
            }
            
            if(hour == minute && second > 0){
              it[hour] = hour_color;
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
                          
            if(second > 59){
              it.all() = Color(255,255,255);
            }
            
      - addressable_lambda:
          name: Clock Flicker
          update_interval: 75ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }

            if(rand() % 4 > 0){
              it.all() = Color(0,0,0);
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
            
      - addressable_lambda:
          name: Clock Fly
          update_interval: 50ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
  
            static float position;
            static float destination;
            static int length;
            static float direction;
            static int speed;
            static float jump;
            static int state = 0;  
            static int step;
            const Color fly_color = Color(255,255,0);
            const int pause = 4;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
  
            if(initial_run){
              position = 0.0;
              state = 2;
              srand(time.hour + minute + second);
            }
  
            if(state == 0){
              state = 1;
              direction = rand() % 2;
              if(direction == 0.0) direction = -1.0;
              length = rand() % 20 + 5;
              speed = rand() % 10 + 1;
              jump = float(speed) / 2.5;
              ESP_LOGD("same", "Position %0.2f, dir %0.2f, length %d, speed %d, jump %0.2f", position, direction, length, speed, jump);
              step = 0;
            }
  
            if(state == 1){
              position = position + (jump * direction);
              if(position < 0) position += 60;
              if(position > 59) position -= 60;
              it[int(position)] = fly_color;
              if(++step >= length){
                step = 0;
                state = 2;
              }
            }
  
            if(state == 2){
              it[int(position)] = fly_color;
              if(++step >= pause){
                state = 0;
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
          
      - addressable_lambda:
          name: Clock Glitter
          update_interval: 18ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            static int state = 0;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }

            if(state==0){
              int i = rand() % it.size();
              it[i] = current_color;
              state += 1;
            } else {
              state += 1;
              state = state % 10;
            }
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
            
      - addressable_lambda:
          name: Clock Inverse
          update_interval: 100ms
          lambda:
            const Color hour_color = Color(0,0,0);
            const Color minute_color = Color(0,0,0);
            const Color second_color = Color(0,0,0);
            int hour;
            int hour_adj;
            int minute;
            int second;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = current_color;
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }

            
      - addressable_lambda:
          name: Clock Marquee
          update_interval: 75ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int hour_adj;
            int minute;
            int second;
            static int step = 0;
            const int width = 4;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = (time.hour % 12) * 5;
            minute = time.minute;
            second = time.second;
            
            hour_adj = 5 * minute / 60;
            hour = hour + hour_adj;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i % (it.size() / 12) == 0){
                  it[i] = minor_indicator_color;
                }
              }
              if(id(marker_setting) > 0){
                if(i % (it.size() / 4) == 0){
                  it[i] = indicator_color;
                }
              }
            }
      
            for (int i = it.size()/2; i >= 0; i--) {
              if(i % width == step){
                it[i] = current_color;
                it[it.size() - i] = current_color;
              } 
            }
      
            step += 1;
            if (step >= width){
              step = 0;
            }
            
            if(second < 60){
              it[second] = second_color;
            }
            it[minute] = minute_color;
            it[hour] = hour_color;
            
            if(hour == minute && second > 1){
              if(second % 2 == 1){
                it[minute] = minute_color;
                ESP_LOGD("same", "Hour equal minute");
              }
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }

            
      - addressable_lambda:
          name: Clock Tourbillon
          update_interval: 33ms
          lambda:
            const Color hour_color = Color(255,0,0);
            const Color minute_color = Color(0,200,0);
            const Color second_color = Color(0,145,255);
            const Color indicator_color = Color(110,0,135);
            const Color minor_indicator_color = Color(65,0,65);
            int hour;
            int minute;
            int second;
            static int state = 0;
            static int step;
            static int hour_loc = 31;
            static int min_loc = 0;
            
            auto time = id(esptime).now();
            if (!time.is_valid()) {
              return;
            }
            
            hour = time.hour % 12;
            if(hour == 0) hour = 12;
            hour = 30 + (hour * 2);
            minute = 30 - (time.minute / 2);
            second = time.second;
            
            it.all() = Color(0,0,0);
            
            for(int i = 0; i < it.size();i++){
              if(id(marker_setting) > 1){
                if(i < 30){
                  if(i % (it.size() / 12) == 0){
                    it[i] = minor_indicator_color;
                  }
                } else if (i > 30 && i < 55){
                  if((i - 30) % 4 == 0){
                    it[i] = minor_indicator_color;
                  }
                }
              }
              if(id(marker_setting) > 0){
                if(i < 30){
                  if(i % (it.size() / 4) == 0){
                    it[i] = indicator_color;
                  }
                } else if (i > 30 && i < 55){
                  if(i == 42 || i == 54){
                    it[i] = indicator_color;
                  }
                }
              }
            }
              
            if(second == 1 ){
              step = -1;
              for(int i = 30; i >= min_loc; i--){
                it[i] = minute_color;
              }
              if(min_loc > minute){
                min_loc += step;
              }
            } else {
              for(int i = minute; i < 31; i++){
                it[i] = minute_color;
              }
              min_loc = 30;
            }
              
            if(second == 0 ){
              step = 1;
              for(int i = 31; i <= hour_loc; i++){
                if(i % 2 == 0){
                  it[i] = hour_color;
                }
              }
              if(hour_loc < hour){
                hour_loc += step;
              }
            } else {
              for(int i = hour;i > 30; i--){
                if(i % 2 == 0){
                  it[i] = hour_color;
                }
              }
              hour_loc = 31;
            }

            if(second % 2 == 1){
              it[0] = second_color;
            } else {
              it[0] = Color(0,0,0);
            }
            
            if(second > 59){
              it.all() = Color(255,255,255);
            }
          
      - strobe:
          name: Color Test
          colors:
            - state: True
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: True
              brightness: 0%
              red: 0%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: True
              brightness: 100%
              red: 0%
              green: 100%
              blue: 0%
              duration: 500ms
            - state: True
              brightness: 0%
              red: 0%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: True
              brightness: 100%
              red: 0%
              green: 0%
              blue: 100%
              duration: 500ms
            - state: True
              brightness: 0%
              red: 0%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: True
              brightness: 100%
              red: 100%
              green: 100%
              blue: 100%
              duration: 500ms
            - state: True
              brightness: 0%
              red: 0%
              green: 0%
              blue: 0%
              duration: 500ms
              
      - addressable_lambda:
          name: Color Wipe
          update_interval: 33ms
          lambda:
            static int wipe = 0;
            static int step = 0;
            Color wipe_color;

            if(step == 0) wipe_color = Color(255,0,0);
            if(step == 1) wipe_color = Color(0,255,0);
            if(step == 2) wipe_color = Color(0,0,255);
            if(step == 3) wipe_color = Color(255,255,255);;

            for(int i = 0; i <= wipe; i++){
              it[i] = wipe_color;
            }

            if(wipe < 60){
              wipe++;
            } else {
              wipe = 0;
              step = ++step % 4;
            }
  
      
      - addressable_lambda:
          name: Police 3
          update_interval: 20ms
          lambda:
            static int color_state;
            static int color_start;
            static int first_color;
            static int cycle;
      
            const int width = 10;
            const int flash_width = 2;
            const int cycle_limit = 6;
      
            int state = 0;
      
            if(initial_run){
              state = 0;
              color_state = 0;
              color_start = 0;
              first_color = 0;
              cycle = 0;
            }
      
            state = state + color_start;
            color_state = first_color;
      
            for (int i = 0; i < it.size(); i++) {
              if(color_state == 0){
                it[i] = Color(255,0,0);
              } else {
                it[i] = Color(0,0,255);
              }
              if(cycle == 1 && state < flash_width){
                it[i] = Color(255,255,255);
              }
      
              state += 1;
              if(state >= width){
                state = 0;
                color_state += 1;
                color_state = color_state % 2;
              }
            }
      
            cycle += 1;
            if(cycle >= cycle_limit){
                cycle = 0;
                color_start += 1;
                if(color_start >= width){
                  color_start = 0;
                  first_color += 1;
                  first_color = first_color % 2;
                }
            }

      - addressable_rainbow:
          name: "Rainbow Spinner"
          speed: 8
          width: 60
      